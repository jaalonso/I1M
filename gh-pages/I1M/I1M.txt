-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Código de I1M.
--   
--   En este paquete se encuentra los códigos de las librerías
--   desarrolladas en el curso de <a>Informática</a> de 1º del Grado en
--   Matemáticas de la Universidad de Sevilla.
@package I1M
@version 0.0.1


-- | <h1>Analizadores sintácticos de expresiones aritméticas.</h1>
--   
--   Este módulo contiene la definición de los analizadores sintácticos de
--   expresiones aritméticas estudiados en el <a>tema 12</a> del curso.
module I1M.Analizador

-- | El tipo de los analizadores.
type Analizador a = String -> [(a, String)]

-- | (analiza a cs) es el resultado de aplicar el analizador a a la cadena
--   cs.
analiza :: Analizador a -> String -> [(a, String)]

-- | El analizador (resultado v`) siempre tiene éxito, devuelve v y no
--   consume nada. Por ejemplo,
--   
--   <pre>
--   analiza (resultado 3) "Hola"  ==  [(3,"Hola")]
--   </pre>
resultado :: a -> Analizador a

-- | El analizador <tt>fallo</tt> siempre falla. Por ejemplo,
--   
--   <pre>
--   analiza fallo "Hola"  ==  []
--   </pre>
fallo :: Analizador a

-- | El analizador <tt>elemento</tt> falla si la cadena es vacía y consume
--   el primer elemento en caso contrario. Por ejemplo,
--   
--   <pre>
--   analiza elemento "Hola"  ==  [('H',"ola")]
--   analiza elemento ""      ==  []
--   </pre>
elemento :: Analizador Char

-- | ((p &gt;*&gt; f) e) falla si el análisis de e por p falla, en caso
--   contrario, se obtiene un valor (v) y una salida (s), se aplica la
--   función f al valor v obteniéndose un nuevo analizador con el que se
--   analiza la salida s.
(>*>) :: Analizador a -> (a -> Analizador b) -> Analizador b
infixr 5 >*>

-- | ((p +++ q) e) analiza e con p y si falla analiza e con q. Por ejemplo,
--   
--   <pre>
--   analiza (elemento +++ resultado 'd') "abc"  ==  [('a',"bc")]
--   analiza (fallo +++ resultado 'd') "abc"     ==  [('d',"abc")]
--   analiza (fallo +++ fallo) "abc"             ==  []
--   </pre>
(+++) :: Analizador a -> Analizador a -> Analizador a

-- | (sat p) es el analizador que consume un elemento si dicho elemento
--   cumple la propiedad p y falla en caso contrario. Por ejemplo,
--   
--   <pre>
--   analiza (sat isLower) "hola"  ==  [('h',"ola")]
--   analiza (sat isLower) "Hola"  ==  []
--   </pre>
sat :: (Char -> Bool) -> Analizador Char

-- | <tt>digito</tt> analiza si el primer carácter es un dígito. Por
--   ejemplo,
--   
--   <pre>
--   analiza digito "123"  ==  [('1',"23")]
--   analiza digito "uno"  ==  []
--   </pre>
digito :: Analizador Char

-- | <tt>`minuscula</tt> analiza si el primer carácter es una letra
--   minúscula. Por ejemplo,
--   
--   <pre>
--   analiza minuscula "eva"  ==  [('e',"va")]
--   analiza minuscula "Eva"  ==  []
--   </pre>
minuscula :: Analizador Char

-- | <tt>mayuscula</tt> analiza si el primer carácter es una letra
--   mayúscula. Por ejemplo,
--   
--   <pre>
--   analiza mayuscula "Eva"  ==  [('E',"va")]
--   analiza mayuscula "eva"  ==  []
--   </pre>
mayuscula :: Analizador Char

-- | <tt>letra</tt> analiza si el primer carácter es una letra. Por
--   ejemplo,
--   
--   <pre>
--   analiza letra "Eva"  ==  [('E',"va")]
--   analiza letra "eva"  ==  [('e',"va")]
--   analiza letra "123"  ==  []
--   </pre>
letra :: Analizador Char

-- | <tt>alfanumerico</tt> analiza si el primer carácter es una letra o un
--   número. Por ejemplo,
--   
--   <pre>
--   analiza alfanumerico "Eva"   ==  [('E',"va")]
--   analiza alfanumerico "eva"   ==  [('e',"va")]
--   analiza alfanumerico "123"   ==  [('1',"23")]
--   analiza alfanumerico " 123"  ==  []
--   </pre>
alfanumerico :: Analizador Char

-- | <tt>(caracter x)</tt> analiza si el primer carácter es igual al
--   carácter x. Por ejemplo,
--   
--   <pre>
--   analiza (caracter 'E') "Eva"  ==  [('E',"va")]
--   analiza (caracter 'E') "eva"  ==  []
--   </pre>
caracter :: Char -> Analizador Char

-- | <tt>(cadena c)</tt> analiza si empieza con la cadena c. Por ejemplo,
--   
--   <pre>
--   analiza (cadena "abc") "abcdef"  ==  [("abc","def")]
--   analiza (cadena "abc") "abdcef"  ==  []
--   </pre>
cadena :: String -> Analizador String

-- | (varios p) aplica el analizador p cero o más veces. Por ejemplo,
--   
--   <pre>
--   analiza (varios digito) "235abc"  ==  [("235","abc")]
--   analiza (varios digito) "abc235"  ==  [("","abc235")]
--   </pre>
varios :: Analizador a -> Analizador [a]

-- | (varios1 p) aplica el analizador p una o más veces. Por ejemplo,
--   
--   <pre>
--   analiza (varios1 digito) "235abc"  ==  [("235","abc")]
--   analiza (varios1 digito) "abc235"  ==  []
--   </pre>
varios1 :: Analizador a -> Analizador [a]

-- | <tt>ident</tt> analiza si comienza con un identificador (i.e. una
--   cadena que comienza con una letra minúscula seguida por caracteres
--   alfanuméricos). Por ejemplo,
--   
--   <pre>
--   analiza ident "lunes12 de Ene"  ==  [("lunes12"," de Ene")]
--   analiza ident "Lunes12 de Ene"  ==  []
--   </pre>
ident :: Analizador String

-- | <tt>nat</tt> analiza si comienza con un número natural. Por ejemplo,
--   
--   <pre>
--   analiza nat "14DeAbril"   ==  [(14,"DeAbril")]
--   analiza nat " 14DeAbril"  ==  []
--   </pre>
nat :: Analizador Int

-- | <tt>espacio</tt> analiza si comienza con espacios en blanco. Por
--   ejemplo,
--   
--   <pre>
--   analiza espacio "    a b c"  ==  [((),"a b c")]
--   </pre>
espacio :: Analizador ()

-- | (unidad p) ignora los espacios en blanco y aplica el analizador
--   <tt>p</tt>. Por ejemplo,
--   
--   <pre>
--   analiza (unidad nat) " 14DeAbril"     ==  [(14,"DeAbril")]
--   analiza (unidad nat) " 14   DeAbril"  ==  [(14,"DeAbril")]
--   </pre>
unidad :: Analizador a -> Analizador a

-- | <tt>identificador</tt> analiza un identificador ignorando los espacios
--   delante y detrás. Por ejemplo,
--   
--   <pre>
--   analiza identificador "  lunes12  de Ene"  ==  [("lunes12","de Ene")]
--   </pre>
identificador :: Analizador String

-- | <tt>natural</tt> analiza un número natural ignorando los espacios
--   delante y detrás. Por ejemplo,
--   
--   <pre>
--   analiza natural "  14DeAbril"  ==  [(14,"DeAbril")]
--   </pre>
natural :: Analizador Int

-- | (simbolo xs) analiza la cadena <tt>xs</tt> ignorando los espacios
--   delante y detrás. Por ejemplo,
--   
--   <pre>
--   analiza (simbolo "abc") "  abcdef"  ==  [("abc","def")]
--   </pre>
simbolo :: String -> Analizador String

-- | <tt>listaNat</tt> analiza una lista de naturales ignorando los
--   espacios. Por ejemplo,
--   
--   <pre>
--   analiza listaNat " [  2,  3, 5   ]"  ==  [([2,3,5],"")]
--   analiza listaNat " [  2,  3,]"       ==  []
--   </pre>
listaNat :: Analizador [Int]

-- | <tt>expr</tt> analiza una expresión aritmética devolviendo su valor.
--   Por ejemplo,
--   
--   <pre>
--   analiza expr "2*3+5"     ==  [(11,"")]
--   analiza expr "2*(3+5)"   ==  [(16,"")]
--   analiza expr "2+3*5"     ==  [(17,"")]
--   analiza expr "2*3+5abc"  ==  [(11,"abc")]
--   </pre>
expr :: Analizador Int

-- | (valor cs) analiza la cadena cs devolviendo su valor si es una
--   expresión aritmética y un mensaje de error en caso contrario. Por
--   ejemplo,
--   
--   <pre>
--   valor "2*3+5"      ==  11
--   valor "2*(3+5)"    ==  16
--   valor "2 * 3 + 5"  ==  11
--   valor "2*3x+5y"    ==  *** Exception: entrada sin usar x+5y
--   valor "-1"         ==  *** Exception: entrada no valida
--   </pre>
valor :: String -> Int


-- | <h2>TAD (tipo abstracto de datos) de los árboles binarios de
--   búsqueda.</h2>
--   
--   Este módulo contiene el código del TAD de los árboles binarios
--   estudiado en el <a>tema 19</a> del curso.
--   
--   Un árbol binario de búsqueda (ABB) es un árbol binario tal que el
--   valor de cada nodo es mayor que los valores de su subárbol izquierdo y
--   es menor que los valores de su subárbol derecho y, además, ambos
--   subárboles son árboles binarios de búsqueda. Por ejemplo, al almacenar
--   los valores de [2,3,4,5,6,8,9] en un ABB se puede obtener los
--   siguientes ABB:
--   
--   <pre>
--      5                     5
--     / \                   / \
--    /   \                 /   \
--   2     6               3     8
--    \     \             / \   / \
--     4     8           2   4 6   9
--    /       \
--   3         9
--   </pre>
--   
--   El objetivo principal de los ABB es reducir el tiempo de acceso a los
--   valores.
--   
--   En los ejemplos se usarán los siguientes ABB:
--   
--   <pre>
--   abb1, abb2 :: ABB Int
--   abb1 = crea (reverse [5,2,6,4,8,3,9])
--   abb2 = foldr inserta vacio (reverse [5,2,4,3,8,6,7,10,9,11])
--   </pre>
module I1M.ArbolBin

-- | El tipo de dato de los ABB,
data ABB a

-- | vacio es el ABB vacío. Por ejemplo,
--   
--   <pre>
--   ghci&gt; vacio
--    -
--   </pre>
vacio :: ABB a

-- | (inserta v a) es el árbol obtenido añadiendo el valor v al ABB a, si
--   no es uno de sus valores. Por ejemplo,
--   
--   <pre>
--   ghci&gt; inserta 7 abb1
--    (5 (2 - (4 (3 - -) -)) (6 - (8 (7 - -) (9 - -))))
--   </pre>
inserta :: (Ord a, Show a) => a -> ABB a -> ABB a

-- | (elimina v a) es el ABB obtenido borrando el valor v del ABB a. Por
--   ejemplo,
--   
--   <pre>
--   ghci&gt; abb1
--    (5 (2 - (4 (3 - -) -)) (6 - (8 - (9 - -))))
--   ghci&gt; elimina 3 abb1
--    (5 (2 - (4 - -)) (6 - (8 - (9 - -))))
--   ghci&gt; elimina 2 abb1
--    (5 (4 (3 - -) -) (6 - (8 - (9 - -))))
--   ghci&gt; elimina 5 abb1
--    (6 (2 - (4 (3 - -) -)) (8 - (9 - -)))
--   ghci&gt; elimina 7 abb1
--    (5 (2 - (4 (3 - -) -)) (6 - (8 - (9 - -))))
--   </pre>
elimina :: (Ord a, Show a) => a -> ABB a -> ABB a

-- | (crea vs) es el ABB cuyos valores son vs. Por ejemplo,
--   
--   <pre>
--   ghci&gt; crea [3,7,2]
--    (2 - (7 (3 - -) -))
--   </pre>
crea :: (Ord a, Show a) => [a] -> ABB a

-- | (crea' vs) es el ABB de menor profundidad cuyos valores son los de la
--   lista ordenada vs. Por ejemplo,
--   
--   <pre>
--   ghci&gt; crea' [2,3,7]
--    (3 (2 - -) (7 - -))
--   </pre>
crea' :: (Ord a, Show a) => [a] -> ABB a

-- | (menor a) es el mínimo valor del ABB a. Por ejemplo,
--   
--   <pre>
--   menor abb1  ==  2
--   </pre>
menor :: Ord a => ABB a -> a

-- | (elementos a) es la lista de los valores de los nodos del ABB en el
--   recorrido inorden. Por ejemplo,
--   
--   <pre>
--   elementos abb1  ==  [2,3,4,5,6,8,9]
--   elementos abb2  ==  [2,3,4,5,6,7,8,9,10,11]
--   </pre>
elementos :: (Ord a, Show a) => ABB a -> [a]

-- | (pertenece v' a) se verifica si v' es el valor de algún nodo del ABB
--   a. Por ejemplo,
--   
--   <pre>
--   pertenece 3 abb1  ==  True
--   pertenece 7 abb1  ==  False
--   </pre>
pertenece :: (Ord a, Show a) => a -> ABB a -> Bool

-- | (valido a) se verifica si a es un ABB correcto. Por ejemplo,
--   
--   <pre>
--   valido abb1 == True
--   </pre>
valido :: (Ord a, Show a) => ABB a -> Bool
instance GHC.Classes.Eq a => GHC.Classes.Eq (I1M.ArbolBin.ABB a)
instance (GHC.Show.Show a, GHC.Classes.Ord a) => GHC.Show.Show (I1M.ArbolBin.ABB a)


-- | TAD (tipo abstracto de datos) de las colas.
--   
--   Este módulo contiene el código del TAD de las colas estudiado en el
--   <a>tema 15</a> del curso.
module I1M.Cola

-- | Tipo de las colas.
data Cola a

-- | c1 es un ejemplo de cola que se usará en los siguientes ejemplos.
--   
--   <pre>
--   ghci&gt; c1
--   C [10,9,8,7,6,5,4,3,2,1]
--   </pre>
--   
--   c1 = foldr inserta vacia [1..10]
--   
--   vacia es la cola vacía. Por ejemplo,
--   
--   <pre>
--   ghci&gt; vacia
--   C []
--   </pre>
vacia :: Cola a

-- | (inserta x c) es la cola obtenida añadiendo x al final de la cola c.
--   Por ejemplo,
--   
--   <pre>
--   inserta 12 (foldr inserta vacia [1..10])  ==  C [10,9,8,7,6,5,4,3,2,1,12]
--   </pre>
inserta :: a -> Cola a -> Cola a

-- | (primero c) es el primer elemento de la cola c. Por ejemplo,
--   
--   <pre>
--   primero (foldr inserta vacia [1..10])  ==  10
--   </pre>
primero :: Cola a -> a

-- | (resto c) es la cola obtenida eliminando el primer elemento de la cola
--   c. Por ejemplo,
--   
--   <pre>
--   resto (foldr inserta vacia [1..10])  ==  C [9,8,7,6,5,4,3,2,1]
--   </pre>
resto :: Cola a -> Cola a

-- | (esVacia c) se verifica si c es la cola vacía. Por ejemplo,
--   
--   <pre>
--   esVacia (foldr inserta vacia [1..10])  ==  False
--   esVacia vacia                          ==  True
--   </pre>
esVacia :: Cola a -> Bool

-- | (valida c) se verifica si c representa una cola válida. Con esta
--   representación, todas las colas son válidas.
valida :: Cola a -> Bool
instance GHC.Classes.Eq a => GHC.Classes.Eq (I1M.Cola.Cola a)
instance GHC.Show.Show a => GHC.Show.Show (I1M.Cola.Cola a)


-- | TAD (tipo abstracto de datos) de los conjuntos.
--   
--   Este módulo contiene el código del TAD de los conjuntos estudiado en
--   el <a>tema 17</a> del curso.
module I1M.Conjunto

-- | Tipo de dato de los conjuntos.
data Conj a

-- | vacio es el conjunto vacío. Por ejemplo,
--   
--   <pre>
--   ghci&gt; vacio
--   {}
--   </pre>
vacio :: Conj a

-- | (esVacio c) se verifica si c es el conjunto vacío. Por ejemplo,
--   
--   <pre>
--   λ&gt; esVacio (foldr inserta vacio [2,5])
--   False
--   λ&gt; esVacio vacio
--   True
--   </pre>
esVacio :: Conj a -> Bool

-- | (pertenece x c) se verifica si x pertenece al conjunto c. Por ejemplo,
--   
--   <pre>
--   λ&gt; let c1 = foldr inserta vacio [2,5,3,2]
--   λ&gt; pertenece 3 c1
--   True
--   λ&gt; pertenece 4 c1
--   False
--   </pre>
pertenece :: Ord a => a -> Conj a -> Bool

-- | (inserta x c) es el conjunto obtenido añadiendo el elemento x al
--   conjunto c. Por ejemplo,
--   
--   <pre>
--   λ&gt; let c1 = foldr inserta vacio [2,5,3,2]
--   λ&gt; c1
--   {2,3,5}
--   λ&gt; inserta 3 c1
--   {2,3,5}
--   λ&gt; inserta 4 c1
--   {2,3,4,5}
--   </pre>
inserta :: Ord a => a -> Conj a -> Conj a

-- | (elimina x c) es el conjunto obtenido eliminando el elemento x del
--   conjunto c. Por ejemplo,
--   
--   <pre>
--   λ&gt; let c1 = foldr inserta vacio [2,5,3,2]
--   λ&gt; c1
--   {2,3,5}
--   λ&gt; elimina 3 c1
--   {2,5}
--   λ&gt; elimina 7 c1
--   {2,3,5}
--   </pre>
elimina :: Ord a => a -> Conj a -> Conj a
instance GHC.Classes.Eq a => GHC.Classes.Eq (I1M.Conjunto.Conj a)
instance GHC.Show.Show a => GHC.Show.Show (I1M.Conjunto.Conj a)


-- | <h1>El patrón "divide y vencerás"</h1>
--   
--   La técnica "divide y vencerás" consta de los siguientes pasos:
--   
--   <ol>
--   <li>Dividir el problema en subproblemas menores.</li>
--   <li>Resolver por separado cada uno de los subproblemas; si los
--   subproblemas son complejos, usar la misma técnica recursivamente; si
--   son simples, resolverlos directamente.</li>
--   <li>Combinar todas las soluciones de los subproblemas en una solución
--   simple.</li>
--   </ol>
--   
--   Este módulo contiene la definición del patrón "divide y vencerás"
--   estudiado en el <a>tema 15</a> del curso. Además, en el tema se
--   incluye dos casos de aplicación del patrón:
--   
--   <ul>
--   <li><a>la ordenación por mezcla</a> y</li>
--   <li><a>la ordenación rápida</a>.</li>
--   </ul>
module I1M.DivideVenceras

-- | (divideVenceras ind resuelve divide combina pbInicial) resuelve el
--   problema pbInicial mediante la técnica de divide y vencerás, donde
--   
--   <ul>
--   <li>(ind pb) se verifica si el problema pb es indivisible</li>
--   <li>(resuelve pb) es la solución del problema indivisible pb</li>
--   <li>(divide pb) es la lista de subproblemas de pb</li>
--   <li>(combina pb ss) es la combinación de las soluciones ss de los
--   subproblemas del problema pb.</li>
--   <li>pbInicial es el problema inicial</li>
--   </ul>
divideVenceras :: (p -> Bool) -> (p -> s) -> (p -> [p]) -> (p -> [s] -> s) -> p -> s


-- | <h1>El TAD (tipo abstracto de datos) de los grafos</h1>
--   
--   Este módulo contiene el código del TAD de los grafos estudiado en el
--   <a>tema 22</a> del curso.
--   
--   En los ejemplos se usarán los siguientes grafos:
--   
--   <pre>
--          12
--     1 -------- 2
--     | \78     /|
--     |  \   32/ |
--     |   \   /  |
--   34|     5    |55
--     |   /   \  |
--     |  /44   \ |
--     | /     93\|
--     3 -------- 4
--          61
--   </pre>
--   
--   definido por
--   
--   <pre>
--   ejGrafoND = creaGrafo ND (1,5) [(1,2,12),(1,3,34),(1,5,78),
--                                   (2,4,55),(2,5,32),
--                                   (3,4,61),(3,5,44),
--                                   (4,5,93)]
--   </pre>
--   
--   y el mismo grafo que ejGrafoND pero orientando las aristas;
--   
--   <pre>
--   ejGrafoD = creaGrafo D (1,5) [(1,2,12),(1,3,34),(1,5,78),
--                                 (2,4,55),(2,5,32),
--                                 (3,4,61),(3,5,44),
--                                 (4,5,93)]
--   </pre>
module I1M.Grafo

-- | Orientacion es D (dirigida) ó ND (no dirigida).
data Orientacion
D :: Orientacion
ND :: Orientacion

-- | (Grafo v p) es un grafo con vértices de tipo v y pesos de tipo p.
data Grafo v p

-- | (creaGrafo o cs as) es un grafo (dirigido o no, según el valor de o),
--   con el par de cotas cs y listas de aristas as (cada arista es un trío
--   formado por los dos vértices y su peso). Ver el ejemplo a
--   continuación.
creaGrafo :: (Ix v, Num p) => Orientacion -> (v, v) -> [(v, v, p)] -> Grafo v p

-- | (dirigido g) se verifica si g es dirigido. Por ejemplo,
--   
--   <pre>
--   dirigido ejGrafoD   ==  True
--   dirigido ejGrafoND  ==  False
--   </pre>
dirigido :: (Ix v, Num p) => Grafo v p -> Bool

-- | (adyacentes g v) es la lista de los vértices adyacentes al nodo v en
--   el grafo g. Por ejemplo,
--   
--   <pre>
--   adyacentes ejGrafoND 4  ==  [2,3,5]
--   adyacentes ejGrafoD  4  ==  [5]
--   </pre>
adyacentes :: (Ix v, Num p) => Grafo v p -> v -> [v]

-- | (nodos g) es la lista de todos los nodos del grafo g. Por ejemplo,
--   
--   <pre>
--   nodos ejGrafoND  ==  [1,2,3,4,5]
--   nodos ejGrafoD   ==  [1,2,3,4,5]
--   </pre>
nodos :: (Ix v, Num p) => Grafo v p -> [v]

-- | (aristas g) es la lista de las aristas del grafo g. Por ejemplo,
--   
--   <pre>
--   ghci&gt; aristas ejGrafoD
--   [(1,2,12),(1,3,34),(1,5,78),(2,4,55),(2,5,32),(3,4,61),
--    (3,5,44),(4,5,93)] 
--   ghci&gt; aristas ejGrafoND
--   [(1,2,12),(1,3,34),(1,5,78),(2,1,12),(2,4,55),(2,5,32),
--    (3,1,34),(3,4,61),(3,5,44),(4,2,55),(4,3,61),(4,5,93),
--    (5,1,78),(5,2,32),(5,3,44),(5,4,93)]
--   </pre>
aristas :: (Ix v, Num p) => Grafo v p -> [(v, v, p)]

-- | (aristaEn g a) se verifica si a es una arista del grafo g. Por
--   ejemplo,
--   
--   <pre>
--   aristaEn ejGrafoND (5,1)  ==  True
--   aristaEn ejGrafoND (4,1)  ==  False
--   aristaEn ejGrafoD (5,1)   ==  False
--   aristaEn ejGrafoD (1,5)   ==  True
--   </pre>
aristaEn :: (Ix v, Num p) => Grafo v p -> (v, v) -> Bool

-- | (peso v1 v2 g) es el peso de la arista que une los vértices v1 y v2 en
--   el grafo g. Por ejemplo,
--   
--   <pre>
--   peso 1 5 ejGrafoND  ==  78
--   peso 1 5 ejGrafoD   ==  78
--   </pre>
peso :: (Ix v, Num p) => v -> v -> Grafo v p -> p
instance (GHC.Arr.Ix v, GHC.Show.Show v, GHC.Show.Show p) => GHC.Show.Show (I1M.Grafo.Grafo v p)
instance (GHC.Arr.Ix v, GHC.Classes.Eq p) => GHC.Classes.Eq (I1M.Grafo.Grafo v p)
instance GHC.Show.Show I1M.Grafo.Orientacion
instance GHC.Classes.Eq I1M.Grafo.Orientacion


-- | TAD (tipo abstracto de datos) de los montículos.
--   
--   Este módulo contiene el código del TAD de los montículos estudiado en
--   el <a>tema 20</a> del curso.
--   
--   Un montículo es un árbol binario en el que los valores de cada nodo es
--   menor o igual que los valores de sus hijos. Por ejemplo, 1 / / 2 6 <i>
--   </i> 3 8 9 7 es un montículo, pero 1 / / 3 6 <i> </i> 4 2 9 7 no lo
--   es.
module I1M.Monticulo

-- | El tipo de dato de los montículos.
data Monticulo a

-- | vacio es el montículo vacío.
vacio :: Ord a => Monticulo a

-- | (inserta x m) es el montículo obtenido añadiendo el elemento x al
--   montículo m. Por ejemplo,
--   
--   <pre>
--   ghci&gt; inserta 3 (foldr inserta vacio [6,1,4,8])
--   M 1 2 
--     (M 4 1 (M 8 1 Vacio Vacio) Vacio) 
--     (M 3 1 (M 6 1 Vacio Vacio) Vacio)
--   </pre>
inserta :: Ord a => a -> Monticulo a -> Monticulo a

-- | (menor m) es el menor elemento del montículo m. Por ejemplo,
--   
--   <pre>
--   menor (foldr inserta vacio [6,1,4,8])  ==  1
--   menor (foldr inserta vacio [7,5])      ==  5
--   </pre>
menor :: Ord a => Monticulo a -> a

-- | (resto m) es el montículo obtenido eliminando el menor elemento del
--   montículo m. Por ejemplo,
--   
--   <pre>
--   ghci&gt; resto (foldr inserta vacio [6,1,4,8])
--   M 4 2 (M 8 1 Vacio Vacio) (M 6 1 Vacio Vacio)
--   </pre>
resto :: Ord a => Monticulo a -> Monticulo a

-- | (esVacio m) se verifica si m es el montículo vacío.
esVacio :: Ord a => Monticulo a -> Bool

-- | (valido m) se verifica si m es un montículo; es decir, es un árbol
--   binario en el que los valores de cada nodo es menor o igual que los
--   valores de sus hijos. Por ejemplo,
--   
--   <pre>
--   valido (foldr inserta vacio [6,1,4,8])    ==  True
--   valido (foldr inserta vacio [7,5])        ==  True
--   valido (M 3 5 (M 2 1 Vacio Vacio) Vacio)  ==  False
--   </pre>
valido :: Ord a => Monticulo a -> Bool
instance GHC.Show.Show a => GHC.Show.Show (I1M.Monticulo.Monticulo a)
instance GHC.Classes.Ord a => GHC.Classes.Eq (I1M.Monticulo.Monticulo a)


-- | TAD (tipo abstracto de datos) de las colas de prioridad.
--   
--   Este módulo contiene el código del TAD de las colas de prioridad
--   estudiado en el <a>tema 16</a> del curso.
module I1M.ColaDePrioridad

-- | Tipo de datos de las colas de prioridad.
data CPrioridad a

-- | vacia es la cola de prioridad vacía. Por ejemplo,
--   
--   <pre>
--   vacia  ==  CP Vacio
--   </pre>
vacia :: Ord a => CPrioridad a

-- | (inserta x c) añade el elemento x a la cola de prioridad c. Por
--   ejemplo,
--   
--   <pre>
--   ghci&gt; foldr inserta vacia [3,1,7,2,9]
--   CP (M 1 2 
--         (M 2 2 
--            (M 9 1 VacioM VacioM) 
--            (M 7 1 VacioM VacioM)) 
--         (M 3 1 VacioM VacioM))
--   ghci&gt; inserta 5 (foldr inserta vacia [3,1,7,2,9])
--   CP (M 1 2 
--         (M 2 2 
--            (M 9 1 VacioM VacioM) 
--            (M 7 1 VacioM VacioM)) 
--         (M 3 1 
--            (M 5 1 VacioM VacioM) VacioM))
--   </pre>
inserta :: Ord a => a -> CPrioridad a -> CPrioridad a

-- | (primero c) es la cabeza de la cola de prioridad c. Por ejemplo,
--   
--   <pre>
--   primero (foldr inserta vacia [3,1,7,2,9])  ==  1
--   </pre>
primero :: Ord a => CPrioridad a -> a

-- | (resto c) elimina la cabeza de la cola de prioridad c. Por ejemplo,
--   
--   <pre>
--   ghci&gt; (foldr inserta vacia [3,1,7,2,9])
--   CP (M 1 2 
--         (M 2 2 
--            (M 9 1 VacioM VacioM) 
--            (M 7 1 VacioM VacioM)) 
--         (M 3 1 VacioM VacioM))
--   ghci&gt; resto (foldr inserta vacia [3,1,7,2,9])
--   CP (M 2 2 
--         (M 9 1 VacioM VacioM) 
--         (M 3 1 
--            (M 7 1 VacioM VacioM) VacioM))
--   </pre>
resto :: Ord a => CPrioridad a -> CPrioridad a

-- | (esVacia c) se verifica si la cola de prioridad c es vacía. Por
--   ejemplo,
--   
--   <pre>
--   esVacia (foldr inserta vacia [3,1,7,2,9])  ==  False
--   esVacia vacia                              ==  True
--   </pre>
esVacia :: Ord a => CPrioridad a -> Bool

-- | (valida c) se verifica si c es una cola de prioridad válida. En la
--   representación mediante montículo todas las colas de prioridad son
--   válidas.
valida :: Ord a => CPrioridad a -> Bool
instance GHC.Show.Show a => GHC.Show.Show (I1M.ColaDePrioridad.CPrioridad a)
instance GHC.Classes.Ord a => GHC.Classes.Eq (I1M.ColaDePrioridad.CPrioridad a)


-- | <h1>El patrón de búsqueda por primero el mejor</h1>
--   
--   Este módulo contiene la definición del patrón de búsqueda por primero
--   el mejor estudiado en el <a>tema 15</a> del curso.
--   
--   Además, en el tema se incluye como de aplicación del patrón el
--   <a>problema del 8-puzzle</a>.
module I1M.BusquedaPrimeroElMejor

-- | (buscaPM s o e) es la lista de soluciones del problema de espacio de
--   estado definido por la función sucesores (s), el objetivo (o) y el
--   estado inicial (e), obtenidas buscando por primero el mejor.
buscaPM :: Ord nodo => (nodo -> [nodo]) -> (nodo -> Bool) -> nodo -> [nodo]


-- | <h1>El patrón de búsqueda en escalada</h1>
--   
--   Este módulo contiene la definición del patrón de búsqueda en escalada
--   estudiado en el <a>tema 15</a> del curso.
--   
--   Además, en el tema se incluye como de casos de aplicación del patrón
--   
--   <ul>
--   <li><a>el problema del cambio de monedas</a> y</li>
--   <li>&lt;<a>http://bit.ly/1LIx5ui</a> el algoritmo de Prim del mínimo
--   árbol de expansión&gt;.</li>
--   </ul>
module I1M.BusquedaEnEscalada

-- | (buscaEscalada s o e) es la lista de soluciones del problema de
--   espacio de estado definido por la función sucesores (s), el objetivo
--   (o) y el estado inicial (e), obtenidas buscando por escalada.
buscaEscalada :: Ord nodo => (nodo -> [nodo]) -> (nodo -> Bool) -> nodo -> [nodo]


-- | TAD (tipo abstracto de datos) de las pilas.
--   
--   Este módulo contiene el código del TAD de las pilas estudiado en el
--   <a>tema 14</a> del curso.
module I1M.Pila

-- | Tipo de dato de las pilas.
data Pila a

-- | p1 es un ejemplo de pila que se usará en los siguientes ejemplos:
--   
--   <pre>
--   ghci&gt; p1
--   1|2|3|-
--   </pre>
--   
--   p1 :: Pila Int p1 = apila 1 (apila 2 (apila 3 vacia))
--   
--   vacia es la pila vacía. Por ejemplo,
--   
--   <pre>
--   ghci&gt; vacia
--   -
--   </pre>
vacia :: Pila a

-- | (apila x p) es la pila obtenida añadiendo x encima de la pila p. Por
--   ejemplo,
--   
--   <pre>
--   apila 4 (apila 1 (apila 2 (apila 3 vacia)))  ==  4|1|2|3|-
--   </pre>
apila :: a -> Pila a -> Pila a

-- | (cima p) es la cima de la pila p. Por ejemplo,
--   
--   <pre>
--   cima (apila 1 (apila 2 (apila 3 vacia)))  ==  1
--   </pre>
cima :: Pila a -> a

-- | (desapila p) es la pila obtenida suprimiendo la cima de la pila p. Por
--   ejemplo,
--   
--   <pre>
--   desapila (apila 1 (apila 2 (apila 3 vacia)))  ==  2|3|-
--   </pre>
desapila :: Pila a -> Pila a

-- | (esVacia p) se verifica si p es la pila vacía. Por ejemplo,
--   
--   <pre>
--   esVacia (apila 1 (apila 2 (apila 3 vacia)))  ==  False
--   esVacia vacia                                ==  True
--   </pre>
esVacia :: Pila a -> Bool
instance GHC.Classes.Eq a => GHC.Classes.Eq (I1M.Pila.Pila a)
instance GHC.Show.Show a => GHC.Show.Show (I1M.Pila.Pila a)


-- | <h1>El patrón de búsqueda en espacios de estados</h1>
--   
--   Las características de los problemas de espacios de estados son:
--   
--   <ul>
--   <li>un conjunto de las posibles situaciones o nodos que constituye el
--   espacio de estados; estos son las potenciales soluciones que se
--   necesitan explorar;</li>
--   <li>un conjunto de movimientos de un nodo a otros nodos, llamados los
--   sucesores del nodo;</li>
--   <li>un nodo inicial;</li>
--   <li>un nodo objetivo, que es la solución.</li>
--   </ul>
--   
--   Este módulo contiene la definición del patrón de búsqueda en espacios
--   de estados estudiado en el <a>tema 15</a> del curso. Además, en el
--   tema se incluye dos casos de aplicación del patrón:
--   
--   <ul>
--   <li><a>el problema de las n reinas</a> y</li>
--   <li><a>el problema de la mochila</a>.</li>
--   </ul>
module I1M.BusquedaEnEspaciosDeEstados

-- | (buscaEE s o e) es la lista de soluciones del problema de espacio de
--   estado definido por la función sucesores (s), el objetivo (o) y el
--   estado inicial (e).
buscaEE :: Eq nodo => (nodo -> [nodo]) -> (nodo -> Bool) -> nodo -> [nodo]


-- | <h1>TAD (tipo abstracto de datos) de los polinomios</h1>
--   
--   Este módulo contiene el código del TAD de los polinomios estudiado en
--   el <a>tema 21</a> del curso.
--   
--   En los ejemplos se usarán los siguientes polinomios:
--   
--   <pre>
--   ejPol1, ejPol2, ejPol3:: Polinomio Int
--   ejPol1 = consPol 4 3 (consPol 2 (-5) (consPol 0 3 polCero))
--   ejPol2 = consPol 5 1 (consPol 2 5 (consPol 1 4 polCero))
--   ejPol3 = consPol 4 6 (consPol 1 2 polCero)
--   ejPol5, ejPol6, ejPol7:: Polinomio Float
--   ejPol5 = consPol 4 3 (consPol 2 (-5) (consPol 0 3 polCero))
--   ejPol6 = consPol 5 1 (consPol 2 5 (consPol 1 4 polCero))
--   ejPol7 = consPol 1 2 (consPol 4 6 polCero)
--   </pre>
--   
--   Su escritura es
--   
--   <pre>
--   ejPol1  ==  3*x^4 + -5*x^2 + 3
--   ejPol2  ==  x^5 + 5*x^2 + 4*x
--   ejPol3  ==  6*x^4 + 2*x
--   ejPol5  ==  3.0*x^4 + -5.0*x^2 + 3.0
--   ejPol6  ==  x^5 + 5.0*x^2 + 4.0*x
--   ejPol7  ==  6.0*x^4 + 2.0*x
--   </pre>
module I1M.Pol

-- | Tipo de dato de polinomios.
data Polinomio a

-- | polCero es el polinomio cero. Por ejemplo,
--   
--   <pre>
--   &gt; polCero
--   0
--   </pre>
polCero :: Polinomio a

-- | (esPolCero p) se verifica si p es el polinomio cero. Por ejemplo,
--   
--   <pre>
--   esPolCero polCero  ==  True
--   esPolCero ejPol1   ==  False
--   </pre>
esPolCero :: Polinomio a -> Bool

-- | (consPol n b p) es el polinomio bx^n+p. Por ejemplo,
--   
--   <pre>
--   ejPol2               ==  x^5 + 5*x^2 + 4*x
--   consPol 3 0 ejPol2   ==  x^5 + 5*x^2 + 4*x
--   consPol 3 2 polCero  ==  2*x^3
--   consPol 6 7 ejPol2   ==  7*x^6 + x^5 + 5*x^2 + 4*x
--   consPol 4 7 ejPol2   ==  x^5 + 7*x^4 + 5*x^2 + 4*x
--   consPol 5 7 ejPol2   ==  8*x^5 + 5*x^2 + 4*x
--   </pre>
consPol :: (Num a, Eq a) => Int -> a -> Polinomio a -> Polinomio a

-- | (grado p) es el grado del polinomio p. Por ejemplo,
--   
--   <pre>
--   ejPol3        ==  6*x^4 + 2*x
--   grado ejPol3  ==  4
--   </pre>
grado :: Polinomio a -> Int

-- | (coefLider p) es el coeficiente líder del polinomio p. Por ejemplo,
--   
--   <pre>
--   ejPol3            ==  6*x^4 + 2*x
--   coefLider ejPol3  ==  6
--   </pre>
coefLider :: Num t => Polinomio t -> t

-- | (restoPol p) es el resto del polinomio p. Por ejemplo,
--   
--   <pre>
--   ejPol3           ==  6*x^4 + 2*x
--   restoPol ejPol3  ==  2*x
--   ejPol2           ==  x^5 + 5*x^2 + 4*x
--   restoPol ejPol2  ==  5*x^2 + 4*x
--   </pre>
restoPol :: Polinomio t -> Polinomio t
instance GHC.Classes.Eq a => GHC.Classes.Eq (I1M.Pol.Polinomio a)
instance (GHC.Num.Num a, GHC.Show.Show a, GHC.Classes.Eq a) => GHC.Show.Show (I1M.Pol.Polinomio a)


-- | En este módulo se definen operaciones con el TAD (tipo abstracto de
--   datos) de los polinomios estudiado en el <a>tema 21</a> del curso.
--   
--   En los ejemplos se usarán los siguientes polinomios:
--   
--   <pre>
--   ejPol1, ejPol2, ejPol3, ejTerm:: Polinomio Int
--   ejPol1 = consPol 4 3 (consPol 2 (-5) (consPol 0 3 polCero))
--   ejPol2 = consPol 5 1 (consPol 2 5 (consPol 1 4 polCero))
--   ejPol3 = consPol 4 6 (consPol 1 2 polCero)
--   ejTerm = consPol 1 4 polCero
--   </pre>
module I1M.PolOperaciones

-- | (creaTermino n a) es el término a*x^n. Por ejemplo,
--   
--   <pre>
--   creaTermino 2 5  ==  5*x^2
--   </pre>
creaTermino :: (Num t, Eq t) => Int -> t -> Polinomio t

-- | (termLider p) es el término líder del polinomio p. Por ejemplo,
--   
--   <pre>
--   ejPol2            ==  x^5 + 5*x^2 + 4*x
--   termLider ejPol2  ==  x^5
--   </pre>
termLider :: (Num t, Eq t) => Polinomio t -> Polinomio t

-- | (sumaPol p q) es la suma de los polinomios p y q. Por ejemplo,
--   
--   <pre>
--   ejPol1                 ==  3*x^4 + -5*x^2 + 3
--   ejPol2                 ==  x^5 + 5*x^2 + 4*x
--   sumaPol ejPol1 ejPol2  ==  x^5 + 3*x^4 + 4*x + 3
--   </pre>
sumaPol :: (Num a, Eq a) => Polinomio a -> Polinomio a -> Polinomio a

-- | (multPorTerm t p) es el producto del término t por el polinomio p. Por
--   ejemplo,
--   
--   <pre>
--   ejTerm                     ==  4*x
--   ejPol2                     ==  x^5 + 5*x^2 + 4*x
--   multPorTerm ejTerm ejPol2  ==  4*x^6 + 20*x^3 + 16*x^2
--   </pre>
multPorTerm :: (Num t, Eq t) => Polinomio t -> Polinomio t -> Polinomio t

-- | (multPol p q) es el producto de los polinomios p y q. Por ejemplo,
--   
--   <pre>
--   ghci&gt; ejPol1
--   3*x^4 + -5*x^2 + 3
--   ghci&gt; ejPol2
--   x^5 + 5*x^2 + 4*x
--   ghci&gt; multPol ejPol1 ejPol2
--   3*x^9 + -5*x^7 + 15*x^6 + 15*x^5 + -25*x^4 + -20*x^3 + 15*x^2 + 12*x
--   </pre>
multPol :: (Num a, Eq a) => Polinomio a -> Polinomio a -> Polinomio a

-- | polUnidad es el polinomio unidad. Por ejemplo,
--   
--   <pre>
--   ghci&gt; polUnidad
--   1
--   </pre>
polUnidad :: (Num t, Eq t) => Polinomio t

-- | (valor p c) es el valor del polinomio p al sustituir su variable por
--   c. Por ejemplo,
--   
--   <pre>
--   ejPol1             ==  3*x^4 + -5*x^2 + 3
--   valor ejPol1 0     ==  3
--   valor ejPol1 1     ==  1
--   valor ejPol1 (-2)  ==  31
--   </pre>
valor :: (Num a, Eq a) => Polinomio a -> a -> a

-- | (esRaiz c p) se verifica si c es una raiz del polinomio p. Por
--   ejemplo,
--   
--   <pre>
--   ejPol3           ==  6*x^4 + 2*x
--   esRaiz 1 ejPol3  ==  False
--   esRaiz 0 ejPol3  ==  True
--   </pre>
esRaiz :: (Num a, Eq a) => a -> Polinomio a -> Bool

-- | (derivada p) es la derivada del polinomio p. Por ejemplo,
--   
--   <pre>
--   ejPol2           ==  x^5 + 5*x^2 + 4*x
--   derivada ejPol2  ==  5*x^4 + 10*x + 4
--   </pre>
derivada :: (Eq a, Num a) => Polinomio a -> Polinomio a

-- | (resta p q) es el polinomio obtenido restándole a p el q. Por ejemplo,
--   
--   <pre>
--   ejPol1                  ==  3*x^4 + -5*x^2 + 3
--   ejPol2                  ==  x^5 + 5*x^2 + 4*x
--   restaPol ejPol1 ejPol2  ==  -1*x^5 + 3*x^4 + -10*x^2 + -4*x + 3
--   </pre>
restaPol :: (Num a, Eq a) => Polinomio a -> Polinomio a -> Polinomio a


-- | <h1>Recorrido de grafos en anchura</h1>
--   
--   En los ejemplos se usará el siguiente grafo
--   
--   <pre>
--   +---&gt; 2 &lt;---+
--   |           |
--   |           |
--   1 --&gt; 3 --&gt; 6 --&gt; 5
--   |                 |
--   |                 |
--   +---&gt; 4 &lt;---------+
--   </pre>
--   
--   definido por &gt; g = creaGrafo D (1,6) &gt;
--   [(1,2,0),(1,3,0),(1,4,0),(3,6,0),(5,4,0),(6,2,0),(6,5,0)]
module I1M.RecorridoEnAnchura

-- | (recorridoEnAnchura i g) es el recorrido en anchura del grafo g desde
--   el vértice i, usando colas. Por ejemplo,
--   
--   <pre>
--   recorridoEnAnchura 1 g  ==  [1,4,3,2,6,5]
--   </pre>
recorridoEnAnchura :: (Num p, Ix v) => v -> Grafo v p -> [v]


-- | <h1>Recorrido de grafos en profundidad</h1>
--   
--   En los ejemplos se usará el siguiente grafo
--   
--   <pre>
--   +---&gt; 2 &lt;---+
--   |           |
--   |           |
--   1 --&gt; 3 --&gt; 6 --&gt; 5
--   |                 |
--   |                 |
--   +---&gt; 4 &lt;---------+
--   </pre>
--   
--   definido por &gt; g = creaGrafo D (1,6) &gt;
--   [(1,2,0),(1,3,0),(1,4,0),(3,6,0),(5,4,0),(6,2,0),(6,5,0)]
module I1M.RecorridoEnProfundidad

-- | (recorridoEnProfundidad i g) es el recorrido en profundidad del grafo
--   g desde el vértice i. Por ejemplo,
--   
--   <pre>
--   recorridoEnProfundidad 1 g  ==  [1,2,3,6,5,4]
--   </pre>
recorridoEnProfundidad :: (Num p, Ix v) => v -> Grafo v p -> [v]

-- | (recorridoEnProfundidad' i g) es el recorrido en profundidad del grafo
--   g desde el vértice i, usando la lista de los visitados como
--   acumulador. Por ejemplo,
--   
--   <pre>
--   recorridoEnProfundidad' 1 g  ==  [1,2,3,6,5,4]
--   </pre>
recorridoEnProfundidad' :: (Num p, Ix v) => v -> Grafo v p -> [v]


-- | TAD (tipo abstracto de datos) de las tablas.
--   
--   Este módulo contiene el código del TAD de las tablas estudiado en el
--   <a>tema 18</a> del curso.
--   
--   En los ejemplos se usarán las siguientes tablas:
--   
--   <pre>
--   t1 = tabla [(i,f i) | i &lt;- [1..6] ] 
--        where f x | x &lt; 3     = x
--                  | otherwise = 3-x
--   t2 = tabla [(4,89), (1,90), (2,67)]
--   </pre>
module I1M.Tabla

-- | El tipo de las tablas.
data Tabla i v

-- | (tabla ivs) es la tabla correspondiente a la lista de asociación ivs
--   (que es una lista de pares formados por los índices y los valores).
--   Por ejemplo,
--   
--   <pre>
--   tabla [(4,89), (1,90), (2,67)]  ==  Tbl [(4,89),(1,90),(2,67)]
--   </pre>
tabla :: Eq i => [(i, v)] -> Tabla i v

-- | (valor t i) es el valor del índice i en la tabla t. Por ejemplo,
--   
--   <pre>
--   valor t1 6  ==  -3
--   valor t2 2  ==  67
--   valor t2 5  ==  *** Exception: fuera de rango
--   </pre>
valor :: Eq i => Tabla i v -> i -> v

-- | (modifica (i,x) t) es la tabla obtenida modificando en la tabla t el
--   valor de i por x. Por ejemplo,
--   
--   <pre>
--   valor t1 6                   ==  -3
--   valor (modifica (6,9) t1) 6  ==  9
--   </pre>
modifica :: Eq i => (i, v) -> Tabla i v -> Tabla i v
instance (GHC.Show.Show i, GHC.Show.Show v) => GHC.Show.Show (I1M.Tabla.Tabla i v)
instance (GHC.Classes.Eq i, GHC.Classes.Eq v) => GHC.Classes.Eq (I1M.Tabla.Tabla i v)


-- | <h1>El patrón de programación dinámica</h1>
--   
--   Este módulo contiene la definición del patrón de programación dinámica
--   estudiado en el <a>tema 15</a> del curso.
--   
--   Además, en el tema se incluye como de casos de aplicación del patrón
--   
--   <ul>
--   <li><a>la sucesión de Fibonacci</a>,</li>
--   <li><a>el producto de cadenas de matrices</a>,</li>
--   <li><a>los árboles binarios de búsqueda optimales</a>,</li>
--   <li>&lt;<a>http://bit.ly/1IsuYDe</a> los caminos mínimos entre todos
--   los pares de nodos de un grafo&gt; y</li>
--   <li><a>el problema del viajante</a>.</li>
--   </ul>
module I1M.Dinamica

-- | (dinamica f r) wa la tabla de cálculo dinámica de la función f en el
--   rango r.
dinamica :: Ix i => (Tabla i v -> i -> v) -> (i, i) -> Tabla i v
